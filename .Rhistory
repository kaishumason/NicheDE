#print(1)
X = matrix(NA,nrow(pstg),n_type^2)
for(k in c(1:nrow(pstg))){
#get feature matrix by multiplying effective niche and pstg vector
ps = as.matrix(pstg[k,])
EN_j = round(object@effective_niche[[counter]][k,],2)
cov_j = ps%*%t(EN_j)
#make into a vector
X[k,] = as.vector(t(cov_j))#important to take the transpose
}
#get index, niche pairs that are non existent
null = which(apply(X,2,function(x){sum(x>0)})<M)
X_partial = X
rest = c(1:ncol(X))
if(length(null)>0){
X_partial = X[,-null]
rest = rest[-null]
}
#if expected expression for a spot is 0, remove it
bad_ind  = which(object@null_expected_expression[,j]==0)
#print('Running GLM')
#run neg binom regression
#print(2)
if(length(bad_ind)>0){
full_glm =suppressWarnings({glm(object@counts[-bad_ind,j]~X_partial[-bad_ind,] + offset(log(object@null_expected_expression[-bad_ind,j])), family = "poisson")}) #do full glm
}else{
full_glm = suppressWarnings({glm(object@counts[,j]~X_partial + offset(log(object@null_expected_expression[,j])), family = "poisson")}) #do full glm
}
mu_hat = exp(predict(full_glm))#get mean
#get dicpersion parameter
A = optimize(nb_lik,x = object@counts[,j],mu = mu_hat, lower = 0.05, upper = 100) #get overdispersion parameter
#save dispersion parameter
disp = A$minimum
#save likelihood
liks[j] = -A$objective
View(X)
mean(is.na(X))
mean(is.infinite(X))
glm(object@counts[,j]~X_partial + offset(log(object@null_expected_expression[,j])), family = "poisson")
j
object@counts[,j]
offset(log(object@null_expected_expression[,j]))
mean(is.infinite(offset(log(object@null_expected_expression[,j]))))
mean(is.na(offset(log(object@null_expected_expression[,j]))))
View(X_partial)
glm(object@counts[,j]~X_partial + offset(log(object@null_expected_expression[,j])), family = "poisson")
summary(object@null_expected_expression[,j])
glm(object@counts[-bad_ind,j]~X_partial[-bad_ind,] + offset(log(object@null_expected_expression[-bad_ind,j])), family = "poisson")
glm(object@counts[,j]~X_partial + offset(log(object@null_expected_expression[,j]+0.0007)), family = "poisson")
summary(object@counts[,j])
glm(object@counts[,j]+1~X_partial + offset(log(object@null_expected_expression[,j])), family = "poisson")
glm(object@counts[,j]~X_partial + offset(log(object@null_expected_expression[,j]+0.003)), family = "poisson")
colSums(object@counts)[j]
View(X_partial)
counter = 2
pstg = object@num_cells%*%as.matrix(diag(object@ref_expr[,j]))/object@null_expected_expression[,j]
pstg[,object@ref_expr[,j]<CT_filter] = 0
pstg[pstg<0.05]=0
#get X
#print(1)
X = matrix(NA,nrow(pstg),n_type^2)
for(k in c(1:nrow(pstg))){
#get feature matrix by multiplying effective niche and pstg vector
ps = as.matrix(pstg[k,])
EN_j = round(object@effective_niche[[counter]][k,],2)
cov_j = ps%*%t(EN_j)
#make into a vector
X[k,] = as.vector(t(cov_j))#important to take the transpose
}
#get index, niche pairs that are non existent
null = which(apply(X,2,function(x){sum(x>0)})<M)
X_partial = X
rest = c(1:ncol(X))
if(length(null)>0){
X_partial = X[,-null]
rest = rest[-null]
}
#if expected expression for a spot is 0, remove it
bad_ind  = which(object@null_expected_expression[,j]==0)
#print('Running GLM')
#run neg binom regression
#print(2)
if(length(bad_ind)>0){
full_glm =suppressWarnings({glm(object@counts[-bad_ind,j]~X_partial[-bad_ind,] + offset(log(object@null_expected_expression[-bad_ind,j])), family = "poisson")}) #do full glm
}else{
full_glm = suppressWarnings({glm(object@counts[,j]~X_partial + offset(log(object@null_expected_expression[,j])), family = "poisson")}) #do full glm
}
object@niche_DE$`0.414491557764874`[[1]]
setwd("C:\\Users\\Kaishu\\Dropbox (Penn)\\Visium\\niche_DE_package\\nicheDE_github")
devtools::document()
#make sure that you have the Matrix and abind packages
library(Matrix)
library(abind)
Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS="true")
install.packages("devtools")
options(timeout=9999999)
devtools::install_github("Kmason23/NicheDE") # install
#load counts matrix
data("vignette_counts")
#load coordinate matrix
data("vignette_coord")
#load expression profile matrix
data("vignette_library_matrix")
#load deconvolution matrix
data("vignette_deconv_mat")
#make Niche-DE object
NDE_obj = CreateNicheDEObject(vignette_counts,vignette_coord,
vignette_library_matrix,vignette_deconv_mat,
sigma = c())
NDE_obj = CalculateEffectiveNiche(NDE_obj)
NDE_obj = niche_DE(NDE_obj)
library(nicheDE)
#load counts matrix
data("vignette_counts")
#load coordinate matrix
data("vignette_coord")
#load expression profile matrix
data("vignette_library_matrix")
#load deconvolution matrix
data("vignette_deconv_mat")
#make Niche-DE object
NDE_obj = CreateNicheDEObject(vignette_counts,vignette_coord,
vignette_library_matrix,vignette_deconv_mat,
sigma = c())
NDE_obj = CalculateEffectiveNiche(NDE_obj)
NDE_obj = niche_DE(NDE_obj)
setwd("C:\\Users\\Kaishu\\Dropbox (Penn)\\Visium\\niche_DE_package\\nicheDE_github")
devtools::document()
#make sure that you have the Matrix and abind packages
library(Matrix)
library(abind)
Sys.setenv(R_REMOTES_NO_ERRORS_FROM_WARNINGS="true")
install.packages("devtools")
options(timeout=9999999)
devtools::install_github("Kmason23/NicheDE") # install
library(nicheDE)
#load counts matrix
data("vignette_counts")
#load coordinate matrix
data("vignette_coord")
#load expression profile matrix
data("vignette_library_matrix")
#load deconvolution matrix
data("vignette_deconv_mat")
#make Niche-DE object
NDE_obj = CreateNicheDEObject(vignette_counts,vignette_coord,
vignette_library_matrix,vignette_deconv_mat,
sigma = c())
NDE_obj = CalculateEffectiveNiche(NDE_obj)
NDE_obj = niche_DE(NDE_obj)
warnings()
get_niche_DE_genes(NDE_obj,'interaction',index='stromal',niche = 'tumor_epithelial',direction = 'positive',alpha = 0.05)
get marker genes
fibro_tum_markers = niche_DE_markers(NDE_obj,index = 'stromal',niche1='tumor_epithelial',niche2='B_plasma',0.05)
#preview output
head(fibro_tum_markers)
data("niche_net_ligand_target_matrix")
data("ramilowski_ligand_receptor_list")
fibro_tumor_LR = niche_LR_spot(NDE_obj,ligand_cell = 'tumor_epithelial',receptor_cell = 'stromal',
ligand_target_matrix = niche_net_ligand_target_matrix,
lr_mat = ramilowski_ligand_receptor_list,K = 25,M = 50,alpha = 0.05,truncation_value = 3)
#preview output
head(fibro_tumor_LR)
# Load packages.
library(Seurat)
library(SeuratData)
library(ggplot2)
library(patchwork)
library(scales)
library(dplyr)
library(reshape2)
# Download dataset using SeuratData.
InstallData(ds = "thp1.eccite")
# Setup custom theme for plotting.
custom_theme <- theme(
plot.title = element_text(size=16, hjust = 0.5),
legend.key.size = unit(0.7, "cm"),
legend.text = element_text(size = 14))
devtools::install_github('satijalab/seurat-data')
# Load packages.
library(Seurat)
library(SeuratData)
library(ggplot2)
library(patchwork)
library(scales)
library(dplyr)
library(reshape2)
# Download dataset using SeuratData.
InstallData(ds = "thp1.eccite")
# Setup custom theme for plotting.
custom_theme <- theme(
plot.title = element_text(size=16, hjust = 0.5),
legend.key.size = unit(0.7, "cm"),
legend.text = element_text(size = 14))
# Load object.
eccite <- LoadData(ds = "thp1.eccite")
# Normalize protein.
eccite <- NormalizeData(
object = eccite,
assay = "ADT",
normalization.method = "CLR",
margin = 2)
# Prepare RNA assay for dimensionality reduction:
# Normalize data, find variable features and scale data.
DefaultAssay(object = eccite) <- 'RNA'
eccite <- NormalizeData(object = eccite) %>% FindVariableFeatures() %>% ScaleData()
# Run Principle Component Analysis (PCA) to reduce the dimensionality of the data.
eccite <- RunPCA(object = eccite)
# Run Uniform Manifold Approximation and Projection (UMAP) to visualize clustering in 2-D.
eccite <- RunUMAP(object = eccite, dims = 1:40)
# Generate plots to check if clustering is driven by biological replicate ID,
# cell cycle phase or target gene class.
p1 <- DimPlot(
object = eccite,
group.by = 'replicate',
label = F,
pt.size = 0.2,
reduction = "umap", cols = "Dark2", repel = T) +
scale_color_brewer(palette = "Dark2") +
ggtitle("Biological Replicate") +
xlab("UMAP 1") +
ylab("UMAP 2") +
custom_theme
p2 <- DimPlot(
object = eccite,
group.by = 'Phase',
label = F, pt.size = 0.2,
reduction = "umap", repel = T) +
ggtitle("Cell Cycle Phase") +
ylab("UMAP 2") +
xlab("UMAP 1") +
custom_theme
p3 <- DimPlot(
object = eccite,
group.by = 'crispr',
pt.size = 0.2,
reduction = "umap",
split.by = "crispr",
ncol = 1,
cols = c("grey39","goldenrod3")) +
ggtitle("Perturbation Status") +
ylab("UMAP 2") +
xlab("UMAP 1") +
custom_theme
# Visualize plots.
((p1 / p2 + plot_layout(guides = 'auto')) | p3 )
# Calculate perturbation signature (PRTB).
eccite<- CalcPerturbSig(
object = eccite,
assay = "RNA",
slot = "data",
gd.class ="gene",
nt.cell.class = "NT",
reduction = "pca",
ndims = 40,
num.neighbors = 20,
split.by = "replicate",
new.assay.name = "PRTB")
# Prepare PRTB assay for dimensionality reduction:
# Normalize data, find variable features and center data.
DefaultAssay(object = eccite) <- 'PRTB'
# Use variable features from RNA assay.
VariableFeatures(object = eccite) <- VariableFeatures(object = eccite[["RNA"]])
eccite <- ScaleData(object = eccite, do.scale = F, do.center = T)
# Run PCA to reduce the dimensionality of the data.
eccite <- RunPCA(object = eccite, reduction.key = 'prtbpca', reduction.name = 'prtbpca')
# Run UMAP to visualize clustering in 2-D.
eccite <- RunUMAP(
object = eccite,
dims = 1:40,
reduction = 'prtbpca',
reduction.key = 'prtbumap',
reduction.name = 'prtbumap')
# Generate plots to check if clustering is driven by biological replicate ID,
# cell cycle phase or target gene class.
q1 <- DimPlot(
object = eccite,
group.by = 'replicate',
reduction = 'prtbumap',
pt.size = 0.2, cols = "Dark2", label = F, repel = T) +
scale_color_brewer(palette = "Dark2") +
ggtitle("Biological Replicate") +
ylab("UMAP 2") +
xlab("UMAP 1") +
custom_theme
q2 <- DimPlot(
object = eccite,
group.by = 'Phase',
reduction = 'prtbumap',
pt.size = 0.2, label = F, repel = T) +
ggtitle("Cell Cycle Phase") +
ylab("UMAP 2") +
xlab("UMAP 1") +
custom_theme
q3 <- DimPlot(
object = eccite,
group.by = 'crispr',
reduction = 'prtbumap',
split.by = "crispr",
ncol = 1,
pt.size = 0.2,
cols = c("grey39","goldenrod3")) +
ggtitle("Perturbation Status") +
ylab("UMAP 2") +
xlab("UMAP 1") +
custom_theme
# Visualize plots.
(q1 / q2 + plot_layout(guides = 'auto') | q3)
# Run mixscape.
eccite <- RunMixscape(
object = eccite,
assay = "PRTB",
slot = "scale.data",
labels = "gene",
nt.class.name = "NT",
min.de.genes = 5,
iter.num = 10,
de.assay = "RNA",
verbose = F,
prtb.type = "KO")
# Calculate percentage of KO cells for all target gene classes.
df <- prop.table(table(eccite$mixscape_class.global, eccite$NT),2)
df2 <- reshape2::melt(df)
df2$Var2 <- as.character(df2$Var2)
test <- df2[which(df2$Var1 == "KO"),]
test <- test[order(test$value, decreasing = T),]
new.levels <- test$Var2
df2$Var2 <- factor(df2$Var2, levels = new.levels )
df2$Var1 <- factor(df2$Var1, levels = c("NT", "NP", "KO"))
df2$gene <- sapply(as.character(df2$Var2), function(x) strsplit(x, split = "g")[[1]][1])
df2$guide_number <- sapply(as.character(df2$Var2),
function(x) strsplit(x, split = "g")[[1]][2])
df3 <- df2[-c(which(df2$gene == "NT")),]
p1 <- ggplot(df3, aes(x = guide_number, y = value*100, fill= Var1)) +
geom_bar(stat= "identity") +
theme_classic()+
scale_fill_manual(values = c("grey49", "grey79","coral1")) +
ylab("% of cells") +
xlab("sgRNA")
p1 + theme(axis.text.x = element_text(size = 18, hjust = 1),
axis.text.y = element_text(size = 18),
axis.title = element_text(size = 16),
strip.text = element_text(size=16, face = "bold")) +
facet_wrap(vars(gene),ncol = 5, scales = "free") +
labs(fill = "mixscape class") +theme(legend.title = element_text(size = 14),
legend.text = element_text(size = 12))
install.packages('mixtools')
library(mixtools)
# Run mixscape.
eccite <- RunMixscape(
object = eccite,
assay = "PRTB",
slot = "scale.data",
labels = "gene",
nt.class.name = "NT",
min.de.genes = 5,
iter.num = 10,
de.assay = "RNA",
verbose = F,
prtb.type = "KO")
# Calculate percentage of KO cells for all target gene classes.
df <- prop.table(table(eccite$mixscape_class.global, eccite$NT),2)
df2 <- reshape2::melt(df)
df2$Var2 <- as.character(df2$Var2)
test <- df2[which(df2$Var1 == "KO"),]
test <- test[order(test$value, decreasing = T),]
new.levels <- test$Var2
df2$Var2 <- factor(df2$Var2, levels = new.levels )
df2$Var1 <- factor(df2$Var1, levels = c("NT", "NP", "KO"))
df2$gene <- sapply(as.character(df2$Var2), function(x) strsplit(x, split = "g")[[1]][1])
df2$guide_number <- sapply(as.character(df2$Var2),
function(x) strsplit(x, split = "g")[[1]][2])
df3 <- df2[-c(which(df2$gene == "NT")),]
p1 <- ggplot(df3, aes(x = guide_number, y = value*100, fill= Var1)) +
geom_bar(stat= "identity") +
theme_classic()+
scale_fill_manual(values = c("grey49", "grey79","coral1")) +
ylab("% of cells") +
xlab("sgRNA")
p1 + theme(axis.text.x = element_text(size = 18, hjust = 1),
axis.text.y = element_text(size = 18),
axis.title = element_text(size = 16),
strip.text = element_text(size=16, face = "bold")) +
facet_wrap(vars(gene),ncol = 5, scales = "free") +
labs(fill = "mixscape class") +theme(legend.title = element_text(size = 14),
legend.text = element_text(size = 12))
View(test)
table(Idents(eccite))
sig = Idents(eccite)
sig =
unique(Idents(eccite))
sig
?substr
?str_sub
str_sub('hello',-2)
library(stringr)
str_sub('hello',-2)
class = str_sub(sig,-2)
KO_type = which(class == 'KO')
for(j in KO_type){
}
sig = unique(Idents(eccite))
class = str_sub(sig,-2)
KO_type = which(class == 'KO')
markers <- vector(mode = "list", length = length(KO_type))
names(markers) = sig[KO_type]
counter = 1
for(j in KO_type){
markers[[counter]] = FindMarkers(eccite,ident.1 = sig[j],ident.2 = 'NT')
counter = counter + 1
}
View(markers)
markers[["STAT2 KO"]]
markers[["IFNGR2 KO"]]
check = markers[["IFNGR2 KO"]]
View(check)
which(rownames(check)=='CD274')
which(rownames(check)=='FAM26F')
sig = unique(Idents(eccite))
class = str_sub(sig,-2)
KO_type = which(class == 'KO')
markers <- vector(mode = "list", length = length(KO_type))
names(markers) = sig[KO_type]
counter = 1
for(j in KO_type){
markers[[counter]] = FindMarkers(eccite,ident.1 = 'NT',ident.2 = sig[j])
counter = counter + 1
}
KO_type
sig[KO_type]
check = markers[["IFNGR2 KO"]]
View(check)
# Run DE analysis and visualize results on a heatmap ordering cells by their posterior
# probability values.
Idents(object = eccite) <- "gene"
MixscapeHeatmap(object = eccite,
ident.1 = "NT",
ident.2 = "IFNGR2",
balanced = F,
assay = "RNA",
max.genes = 20, angle = 0,
group.by = "mixscape_class",
max.cells.group = 300,
size=6.5) + NoLegend() +theme(axis.text.y = element_text(size = 16))
View(check)
RidgePlot(eccite,features = 'CD74',Idents = c('NT','IFNGR2 KO'))
RidgePlot(eccite,features = 'CD74',idents = c('NT','IFNGR2 KO'))
unique(Idents(eccite))
# Run mixscape.
eccite <- RunMixscape(
object = eccite,
assay = "PRTB",
slot = "scale.data",
labels = "gene",
nt.class.name = "NT",
min.de.genes = 5,
iter.num = 10,
de.assay = "RNA",
verbose = F,
prtb.type = "KO")
# Calculate percentage of KO cells for all target gene classes.
df <- prop.table(table(eccite$mixscape_class.global, eccite$NT),2)
df2 <- reshape2::melt(df)
df2$Var2 <- as.character(df2$Var2)
test <- df2[which(df2$Var1 == "KO"),]
test <- test[order(test$value, decreasing = T),]
new.levels <- test$Var2
df2$Var2 <- factor(df2$Var2, levels = new.levels )
df2$Var1 <- factor(df2$Var1, levels = c("NT", "NP", "KO"))
df2$gene <- sapply(as.character(df2$Var2), function(x) strsplit(x, split = "g")[[1]][1])
df2$guide_number <- sapply(as.character(df2$Var2),
function(x) strsplit(x, split = "g")[[1]][2])
df3 <- df2[-c(which(df2$gene == "NT")),]
p1 <- ggplot(df3, aes(x = guide_number, y = value*100, fill= Var1)) +
geom_bar(stat= "identity") +
theme_classic()+
scale_fill_manual(values = c("grey49", "grey79","coral1")) +
ylab("% of cells") +
xlab("sgRNA")
p1 + theme(axis.text.x = element_text(size = 18, hjust = 1),
axis.text.y = element_text(size = 18),
axis.title = element_text(size = 16),
strip.text = element_text(size=16, face = "bold")) +
facet_wrap(vars(gene),ncol = 5, scales = "free") +
labs(fill = "mixscape class") +theme(legend.title = element_text(size = 14),
legend.text = element_text(size = 12))
RidgePlot(eccite,features = 'CD74',idents = c('NT','IFNGR2 KO'))
RidgePlot(eccite,features = 'CD74',idents = c('NT','IFNGR2 KO'),assay = 'PTRB')
RidgePlot(eccite,features = 'CD74',idents = c('NT','IFNGR2 KO'),assay = 'PRTB')
RidgePlot(eccite,features = 'IFNGR',idents = c('NT','IFNGR2 KO'),assay = 'PRTB')
RidgePlot(eccite,features = 'IFNGR2',idents = c('NT','IFNGR2 KO'),assay = 'PRTB')
RidgePlot(eccite,features = 'IRF1',idents = c('NT','IFNGR2 KO'),assay = 'PRTB')
RidgePlot(eccite,features = 'IRF1',idents = c('NT','IFNGR2 KO'),assay = 'GDO')
RidgePlot(eccite,features = 'IRF1',idents = c('NT','IFNGR2 KO'),assay = 'RNA')
sig = unique(Idents(eccite))
class = str_sub(sig,-2)
KO_type = which(class == 'KO')
markers <- vector(mode = "list", length = length(KO_type))
names(markers) = sig[KO_type]
counter = 1
for(j in KO_type){
markers[[counter]] = FindMarkers(eccite,ident.1 = 'NT',ident.2 = sig[j],assay = 'RNA')
counter = counter + 1
}
check = markers[["IFNGR2 KO"]]
View(check)
RidgePlot(eccite,features = 'IRF1',idents = c('NT','IFNGR2 KO'),assay = 'PRTB')
install_github("https://github.com/Katsevich-Lab/lowmoi")
library(devtools)
install_github("https://github.com/Katsevich-Lab/lowmoi")
library(Seurat)
data = rep(NA,900*900*20000)
